#include <iostream>
#include <sstream>
#include <algorithm>
#include <ctime>
#include <vector>
using namespace std;

// Placeholder: Implement your HashMap class here (e.g., HashMap<int, TreeNode*>)
class HashMap {
  // TODO: Define internal data structures, hash function, insert/find/remove methods
};

class TreeNode {
public:
    int version_id;
    string content;
    string message; // Empty if not a snapshot
    time_t created_timestamp;
    time_t snapshot_timestamp; // 0 means no snapshot
    TreeNode* parent;
    vector<TreeNode*> children;

    TreeNode(int id, string cont, TreeNode* par)
    {
        this->version_id = id;
        this->content = cont;
        this->message = "";
        this->created_timestamp = time(nullptr);
        this->snapshot_timestamp = 0;
        this->parent = par;
        // children vector auto-initialized empty
    }
};

class File {
public:
    string name;
    TreeNode* root;
    TreeNode* active_version;
    HashMap version_map; // TODO: HashMap<int, TreeNode*>
    int last_ver;   // for assigning version IDs
    int total_versions;

    File(string filename)
    {
        this->name = filename;
        this->last_ver = 0;
        this->total_versions = 1;
        this->root = new TreeNode(0, "", nullptr);
        this->root->message = "Initial Snapshot";
        this->root->snapshot_timestamp = time(nullptr);
        this->active_version = this->root;
        // TODO: Insert root into version_map with key 0
    }

    ~File() {
        // TODO: Delete all TreeNodes recursively to free memory
    }

    void INSERT(string content)
    {
        if (this->active_version->snapshot_timestamp != 0)
        {
            // Active version is a snapshot: create new child version
            TreeNode* new_node = new TreeNode(this->total_versions, this->active_version->content, this->active_version);
            new_node->content += content;
            this->active_version->children.push_back(new_node);
            this->active_version = new_node;
            // TODO: Insert new_node into version_map with key this->total_versions
            this->total_versions++;
        }
        else
        {
            // Modify active version content in place
            this->active_version->content += content;
        }
    }

    void UPDATE(string content)
    {
        if (this->active_version->snapshot_timestamp != 0)
        {
            // Create new child with replaced content
            TreeNode* new_node = new TreeNode(this->total_versions, content, this->active_version);
            this->active_version->children.push_back(new_node);
            this->active_version = new_node;
            // TODO: Insert new_node into version_map
            this->total_versions++;
        }
        else
        {
            // Update current version content in-place
            this->active_version->content = content;
        }
    }

    void SNAPSHOT(string message)
    {
        this->active_version->message = message;
        this->active_version->snapshot_timestamp = time(nullptr);
    }

    void ROLLBACK(int version_id = -1)
    {
        if (version_id == -1)
        {
            if (this->active_version->parent)
                this->active_version = this->active_version->parent;
            else
                cout << "No parent version to rollback to.\n";
        }
        else
        {
            // TODO: Search version_map for version_id and set active_version if found
            cout << "ROLLBACK by version ID not implemented yet.\n";
        }
    }

    void HISTORY()
    {
        vector<TreeNode*> snapshots;
        TreeNode* curr = this->active_version;
        while (curr)
        {
            if (curr->snapshot_timestamp != 0)
                snapshots.push_back(curr);
            curr = curr->parent;
        }
        for (auto it = snapshots.rbegin(); it != snapshots.rend(); ++it)
        {
            cout << "Version " << (*it)->version_id << " - " 
                 << ctime(&((*it)->snapshot_timestamp))
                 << " - " << (*it)->message << endl;
        }
    }
};

// TODO: Implement a FileSystem class managing multiple File objects indexed by filename
// and console command parsing to interactively handle CREATE, READ, INSERT, UPDATE, etc.

int main()
{
    cout << "Time-Travelling File System starting...\n";
    cout << "Commands: CREATE, READ, INSERT, UPDATE, SNAPSHOT, ROLLBACK, HISTORY, EXIT\n";

    // TODO: Build interactive input loop with command parser calling FileSystem methods

    return 0;
}
